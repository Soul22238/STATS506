---
title: "Problem Set 1"
format:
  html:
    embed-resources: true
editor: visual
---

Github link: https://github.com/Soul22238/STATS506

# Problem 1

## a

```{r}
file_path <- "./abalone/abalone.data"
abalone <- read.table(file_path, sep = ",")
abalone.names <- c("Sex", "Length", "Diameter","Height","WholeWeight","ShuckedWeight", "VisceraWeight", "ShellWeight", "Rings")
colnames(abalone) <- abalone.names
```

## b

I used Chatgpt to explain how to make a table. The data contains 1307 female, 1528 male and 1342 Infant.

```{r}
table(abalone$Sex)
```

## c

### 1

The Shell Weight has the highest correlation with Rings.

```{r}
cor(abalone$WholeWeight, abalone$Rings)
cor(abalone$ShuckedWeight, abalone$Rings)
cor(abalone$VisceraWeight, abalone$Rings)
cor(abalone$ShellWeight, abalone$Rings)
```

### 2

The infant have a higher correlation of Shell Weight with Rings.

```{r}
sub_F <- abalone[abalone$Sex == "F",]
sub_I <- abalone[abalone$Sex == "I",]
sub_M <- abalone[abalone$Sex == "M",]
cor(sub_F$ShellWeight, sub_F$Rings)
cor(sub_I$ShellWeight, sub_I$Rings)
cor(sub_M$ShellWeight, sub_M$Rings)
```

### 3

The whole weight of the abalone that has the maximum rings is 1.875. The shucked weight of the abalone that has the maximum rings is 0.7055. The viscera weight of the abalone that has the maximum rings is 0.3215. The shell weight of the abalone that has the maximum rings is 0.475.

```{r}
abalone[abalone$Rings == max(abalone$Rings),]$WholeWeight
abalone[abalone$Rings == max(abalone$Rings),]$ShuckedWeight
abalone[abalone$Rings == max(abalone$Rings),]$VisceraWeight
abalone[abalone$Rings == max(abalone$Rings),]$ShellWeight
```

### 4

About 6.51% of the abalones have a viscera weight larger than their shell weight.

```{r}
length(abalone[abalone$VisceraWeight>abalone$ShellWeight,"Sex"])/length(abalone$Sex) * 100
```

## d

```{r}
weights <- c("WholeWeight", "ShuckedWeight", "VisceraWeight", "ShellWeight")
sexes <- unique(abalone$Sex)

corr_table <- matrix(NA, nrow = length(sexes), ncol = length(weights),
                     dimnames = list(sexes, weights))
for (s in sexes) {
  subdata <- abalone[abalone$Sex == s, ]
  for (w in weights) {
    corr_table[s, w] <- cor(subdata[[w]], subdata$Rings)
  }
}

corr_table
```

## e

I used chatgpt to explain how the t test works. A series of two-sample t-tests was conducted to compare the mean number of rings across the three sexes (F, M, I). The p value for each test is smaller than 0.05. The pairwise t tests reveals significant differences for rings at the 5% level.

```{r}
t.test(Rings ~ Sex, data = abalone, subset = Sex %in% c("M","F"))
t.test(Rings ~ Sex, data = abalone, subset = Sex %in% c("M","I"))
t.test(Rings ~ Sex, data = abalone, subset = Sex %in% c("F","I"))
```

# Problem 2

## a

```{r}
food <- read.csv("food_expenditure.csv")
```

## b

```{r}
colnames(food) <- c(
  "ID",
  "Age",
  "HH_Size",        
  "State",
  "Currency",
  "FoodExp_Total",
  "FoodExp_Grocery",
  "FoodExp_Dining",
  "FoodExp_Misc",
  "Dining_Count",
  "Alcohol_Included",
  "Food_Assist"
)
```

## c

```{r}
length(food$ID)
USD_food <- food[food$Currency == "USD",]
length(USD_food$ID)
```

## d

For the age variable, we excluded individuals under 18 and over 100. Teenagers may not accurately report household food expenditures, and people over 100 may no longer be able to manage their own food consumption.

```{r}
age_criterion <- USD_food$Age <100 & USD_food$Age > 18
```

## e

For the state variable, we only include states in the USA.

```{r}
valid_states <- c(state.abb, "DC", "PR")
state_criterion <- USD_food$State %in% valid_states
```

## f

For the four variables related to food expenditures, values were required to be positive and not excessively large (less than 10000).

```{r}
exp_total_num <- as.numeric(USD_food$FoodExp_Total )
expTotal_criterion<- !is.na(exp_total_num) & exp_total_num >= 0 & exp_total_num < 10000 

exp_grocery_num <- as.numeric(USD_food$FoodExp_Grocery )
expGrocery_criterion<- !is.na(exp_grocery_num) & exp_grocery_num >= 0 & exp_grocery_num < 10000 

exp_dining_num <- as.numeric(USD_food$FoodExp_Dining )
expDining_criterion<- !is.na(exp_dining_num) & exp_dining_num >= 0 & exp_dining_num < 10000 

exp_misc_num <- as.numeric(USD_food$FoodExp_Misc )
expmisc_criterion<- !is.na(exp_misc_num) & exp_misc_num >= 0 & exp_misc_num < 10000 

```

## g

The number of times dining out was treated as a numeric variable, with valid values being non-negative and within a reasonable upper limit (less than 10000).

```{r}
dining_count <- as.numeric(USD_food$Dining_Count)
diningCount_criterion<- !is.na(dining_count) & dining_count >= 0 & dining_count < 10000 

```

## h

The final number of observations after this cleaning is 134.

```{r}


final_food <- USD_food[age_criterion & state_criterion & expTotal_criterion & expGrocery_criterion & expDining_criterion & expmisc_criterion & diningCount_criterion, ]
length(final_food$ID)

```

# Problem 3

## a

I used chatgpt to explain how to check for numeric input and integer.

```{r}
#' Function to computes the next number in its Collatz sequence
#'
#' @param x a positive integer
#' @return next number in its Collatz sequence for `x`
nextCollatz <- function(x) {
  # Check for invalid input
  if (!is.numeric(x) || length(x) != 1) {
    stop("Input must be a single numeric value.")
  }
  if (x <= 0 || x != as.integer(x)) {
    stop("Input must be a positive integer.")
  }
    
  if (x %% 2 == 0) {      
    next_x <- x / 2
  } else {
    next_x <- 3 * x + 1
  }
  return(next_x)
}
nextCollatz(5)
nextCollatz(16)
```

## b

I used chatgpt to explain how to check for numeric input and integer.

```{r}
#' Function to computes a Collatz sequence for a number
#'
#' @param x a positive integer
#' @return next number in its Collatz sequence for `x`
collatzSequence <- function(x) {
  # Check for invalid input
  if (!is.numeric(x) || length(x) != 1) {
    stop("Input must be a single numeric value.")
  }
  if (x <= 0 || x != as.integer(x)) {
    stop("Input must be a positive integer.")
  }
    
  sequence <- c(x)
  num <- x
  while (num != 1){
    num = nextCollatz(num)
    sequence <- c(sequence, num)
  }
  return(list(seq = sequence,length = length(sequence)))
}
collatzSequence(5)
collatzSequence(19)
```

## c

The shortest and longest Collatz sequence start with value 128 and 327

```{r}
shortest <- 1/0
shortest_start <- NA
longest <- -1/0
longest_start <- NA
for (i in seq(100,500)){
  seq_len <- collatzSequence(i)[[2]]
  if (seq_len < shortest){
    shortest <- seq_len
    shortest_start <- i
  }
  if (seq_len > longest){
    longest <- seq_len
    longest_start <- i
  }
}
shortest_start 
longest_start
```
