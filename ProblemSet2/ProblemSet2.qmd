---
title: "Problem Set 2"
format:
  html:
    embed-resources: true
editor: visual
---

Github link: https://github.com/Soul22238/STATS506
# Problem Set 2
## Problem 1
### a
```{r}
#' Function to determine the end position of a random walk using loops
#'
#' @param n number of steps
#' @return The final position of the walk after `n` number of steps
random_walk1 <- function(n){
  cur <- 0
  probs <- 0.5 * c(0.95, 0.05, 0.8, 0.2)
  steps <- sample(c(1, 10, -1, -3), n, prob = probs, replace = TRUE)
  for (i in 1:n){
    cur <- cur + steps[i]
  }
  return(cur) 
}

#' Function to determine the end position of a random walk using built-in R vectorized functions
#'
#' @param n number of steps
#' @return The final position of the walk after `n` number of steps
random_walk2 <- function(n){
  probs <- 0.5 * c(0.95, 0.05, 0.8, 0.2)
  steps <- sample(c(1, 10, -1, -3), n,  prob = probs, replace = TRUE)
  return (sum(steps))
}

#' Function to determine the end position of a random walk using sapply
#'
#' @param n number of steps
#' @return The final position of the walk after `n` number of steps
random_walk3 <- function(n){
  probs <- 0.5 * c(0.95, 0.05, 0.8, 0.2)
  steps <- sample(c(1, 10, -1, -3), n,  prob = probs, replace = TRUE)
  steps <- matrix(steps, nrow = 1)
  return(apply(steps, 1, sum))

}


random_walk1(10)
random_walk2(10)
random_walk3(10)
random_walk1(1000)
random_walk2(1000)
random_walk3(1000)

```
### b
```{r}
set.seed(15)
random_walk1(10)
set.seed(15)
random_walk2(10)
set.seed(15)
random_walk3(10)
set.seed(15)
random_walk1(1000)
set.seed(15)
random_walk2(1000)
set.seed(15)
random_walk3(1000)
```
### c
The results show that the vectorized function consistently outperforms the other implementations, such as loop and apply. The apply function is generally faster than explicit loops because it uses implicit looping internally.
```{r}
library(microbenchmark)
set.seed(123)
microbenchmark(
  loop = random_walk1(1000),
  vectorized = random_walk2(1000),
  apply = random_walk3(1000)
)
set.seed(123)
microbenchmark(
  loop = random_walk1(100000),
  vectorized = random_walk2(100000),
  apply = random_walk3(100000)
)
```

### d
The probability that the random walk ends at 0 is approximately 0.1355 when the number of steps is 10. For 100 steps, the probability decreases to around 0.0217, and for 1,000 steps, it drops further to about 0.0046.
```{r}

n_sim = 10000
result1 <- sapply(1:n_sim, function(i) random_walk2(10))

prob1 <- mean(result1 == 0)

result2 <- sapply(1:n_sim, function(i) random_walk2(100))
prob2 <- mean(result2 == 0)

result3 <- sapply(1:n_sim, function(i) random_walk2(1000))
prob3 <- mean(result3 == 0)
prob1
prob2
prob3
```

## Problem 2
The average number of cars that pass an intersection per day is around 264.
```{r}
n <- 10000
n_sim <- n * c(8,8,6,2)
sim <- c(rpois(n_sim[1],1) , rpois(n_sim[2],8), rpois(n_sim[3],12), rnorm(n_sim[4],mean = 60,sd = sqrt(12)))
sum(sim)/n
```
## Problem 3
### a
```{r}
youtube <- read.csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-03-02/youtube.csv')
youtube_clean <- youtube[, !(names(youtube) %in% c(
  "brand",
  "superbowl_ads_dot_com_url",
  "youtube_url",
  "id",
  "etag",
  "published_at",
  "channel_title",
  "thumbnail",
  "title",
  "description"
))]
dim(youtube_clean)
```
### b
i) N/A
ii) View counts, Like counts, Dislike counts, Comment counts
iii) Favorite counts

Reasoning:
The response variable in a linear regression model should be numerical and continuous. 
View counts, like counts, dislike counts, and comment counts are discrete, so they cannot be used directly as outcomes, but a log transformation can make them more suitable. 
Since all values of favorite_count are zero, it is also not an appropriate outcome variable.
# Since all values of favorite_count are zero, it is also not an appropriate outcome variable.

```{r}

cat("=======view_count========\n")
is.numeric(youtube_clean$view_count)
hist(youtube_clean$view_count)
table(youtube_clean$view_count, useNA = "ifany")

cat("=======like_count========\n")
is.numeric(youtube_clean$like_count)
hist(youtube_clean$like_count)
table(youtube_clean$like_count, useNA = "ifany")

cat("=======dislike_count========\n")
is.numeric(youtube_clean$dislike_count)
hist(youtube_clean$dislike_count)
table(youtube_clean$dislike_count, useNA = "ifany")

cat("=======favorite_count========\n")
is.numeric(youtube_clean$favorite_count)
table(youtube_clean$favorite_count, useNA = "ifany")

cat("=======comment_count========\n")
is.numeric(youtube_clean$comment_count)
hist(youtube_clean$comment_count)
table(youtube_clean$comment_count, useNA = "ifany")

```
The dimension of the table is 219 * 20
```{r}
youtube_clean$view_count_log     <- log1p(youtube_clean$view_count)
youtube_clean$like_count_log     <- log1p(youtube_clean$like_count)
youtube_clean$dislike_count_log  <- log1p(youtube_clean$dislike_count)
youtube_clean$comment_count_log  <- log1p(youtube_clean$comment_count)


```
### c
Based on the p-values of the estimated coefficients, year has a statistically significant effect on like_count, dislike_count, and comment_count at the 5% level. Holding all other variables constant, a one-year increase is associated with an estimated 0.075 increase in log(like_count), a 0.09337 increase in log(dislike_count), and a 0.053 increase in log(comment_count).


Similarly, patrioticTRUE is statistically significant for comment_count at the 5% level. Holding other factors constant, ads labeled as patriotic are associated with an estimated 0.935 higher log(comment_count) compared to non-patriotic ads.
```{r}
youtube_clean <- na.omit(youtube_clean)
dim(youtube_clean)
mod1 <- lm(view_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, youtube_clean)
mod2 <- lm(like_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, youtube_clean)
mod3 <- lm(dislike_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, youtube_clean)
mod4 <- lm(comment_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, youtube_clean)

summary(mod1)
summary(mod2)
summary(mod3)
summary(mod4)



```
### d
```{r}
X <- model.matrix(view_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, data = youtube_clean)
beta1 <- solve(t(X)%*%X)%*%t(X)%*%youtube_clean$view_count_log
beta1

#X2 <- model.matrix(like_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, youtube_clean)
beta2 <- solve(t(X)%*%X)%*%t(X)%*%youtube_clean$like_count_log
beta2
#X3 <- model.matrix(dislike_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, youtube_clean)
beta3 <- solve(t(X)%*%X)%*%t(X)%*%youtube_clean$dislike_count_log
beta3
#X4 <- model.matrix(comment_count_log ~ year + funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex, youtube_clean)
beta4 <- solve(t(X)%*%X)%*%t(X)%*%youtube_clean$comment_count_log
beta4


```