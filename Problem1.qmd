---
title: "Problem Set 1"
format: html
editor: visual
---

# Problem 1

## a

```{r}
file_path <- "./abalone/abalone.data"
abalone <- read.table(file_path, sep = ",")
abalone.names <- c("Sex", "Length", "Diameter","Height","WholeWeight","ShuckedWeight", "VisceraWeight", "ShellWeight", "Rings")
colnames(abalone) <- abalone.names
```

## b

The data contains 1307 female, 1528 male and 1342 Infant

```{r}
table(abalone$Sex)
```

## c

### 1

The Shell Weight has the highest correlation with Rings.

```{r}
cor(abalone$ShuckedWeight, abalone$Rings)
cor(abalone$VisceraWeight, abalone$Rings)
cor(abalone$ShellWeight, abalone$Rings)
```

### 2

The male has a higher correlation of Shell Weight with Rings.

```{r}
sub_F <- abalone[abalone$Sex == "F",]
sub_I <- abalone[abalone$Sex == "M",]
sub_M <- abalone[abalone$Sex == "I",]
cor(sub_F$ShellWeight, sub_F$Rings)
cor(sub_I$ShellWeight, sub_I$Rings)
cor(sub_M$ShellWeight, sub_M$Rings)
```

### 3

The whole weight of the abalone that has the maximum rings is 1.875. The shucked weight of the abalone that has the maximum rings is 0.7055. The viscera weight of the abalone that has the maximum rings is 0.3215. The shell weight of the abalone that has the maximum rings is 0.475.

```{r}
abalone[abalone$Rings == max(abalone$Rings),]$WholeWeight
abalone[abalone$Rings == max(abalone$Rings),]$ShuckedWeight
abalone[abalone$Rings == max(abalone$Rings),]$VisceraWeight
abalone[abalone$Rings == max(abalone$Rings),]$ShellWeight
```

### 4

About 6.51% of the abalones have a viscera weight larger than their shell weight.

```{r}
length(abalone[abalone$VisceraWeight>abalone$ShellWeight,"Sex"])/length(abalone$Sex) * 100
```

## d

```{r}
weights <- c("WholeWeight", "ShuckedWeight", "VisceraWeight", "ShellWeight")
sexes <- unique(abalone$Sex)

corr_table <- matrix(NA, nrow = length(sexes), ncol = length(weights),
                     dimnames = list(sexes, weights))
for (s in sexes) {
  subdata <- abalone[abalone$Sex == s, ]
  for (w in weights) {
    corr_table[s, w] <- cor(subdata[[w]], subdata$Rings)
  }
}

corr_table
```

## e

A series of two-sample t-tests was conducted to compare the mean number of rings across the three sexes (F, M, I). The p value for each test is smaller than 0.05. The pairwise t tests reveals significant differences for rings at the 5% level.

```{r}
t.test(Rings ~ Sex, data = abalone, subset = Sex %in% c("M","F"))
t.test(Rings ~ Sex, data = abalone, subset = Sex %in% c("M","I"))
t.test(Rings ~ Sex, data = abalone, subset = Sex %in% c("F","I"))
```

# Problem 2

## a

```{r}
food <- read.csv("food_expenditure.csv")
```

## b

```{r}
colnames(food) <- c(
  "ID",
  "Age",
  "HH_Size",        
  "State",
  "Currency",
  "FoodExp_Total",
  "FoodExp_Grocery",
  "FoodExp_Dining",
  "FoodExp_Misc",
  "Dining_Count",
  "Alcohol_Included",
  "Food_Assist"
)
```

## c

```{r}
length(food$ID)
USD_food <- food[food$Currency == "USD",]
length(USD_food$ID)
```

## d

For the age variable, we excluded all minors under the age of 18 and larger than 100 because teens may not know the expenditure of food in a family and people at the age larger than 100 may not have the ability to take care of themselves the food.

```{r}
age_criterion <- USD_food$Age <100 & USD_food$Age > 18
```

## e
For the state variable, we only include states in the USA.

```{r}
valid_states <- c(state.abb, "DC", "PR")
state_criterion <- USD_food$State %in% valid_states
```

## f
For the four variables related to food expenditures. The expenses of food must be a positive number and not enormously larger (larger than 10000).
```{r}
exp_total_num <- as.numeric(USD_food$FoodExp_Total )
expTotal_criterion<- !is.na(exp_total_num) & exp_total_num >= 0 & exp_total_num < 10000 

exp_grocery_num <- as.numeric(USD_food$FoodExp_Grocery )
expGrocery_criterion<- !is.na(exp_grocery_num) & exp_grocery_num >= 0 & exp_grocery_num < 10000 

exp_dining_num <- as.numeric(USD_food$FoodExp_Dining )
expDining_criterion<- !is.na(exp_dining_num) & exp_dining_num >= 0 & exp_dining_num < 10000 

exp_misc_num <- as.numeric(USD_food$FoodExp_Misc )
expmisc_criterion<- !is.na(exp_misc_num) & exp_misc_num >= 0 & exp_misc_num < 10000 

```

## g
For the numbers of time dining out, the variable should be a numeric number and larger or equal than 0 and not enormously larger (larger than 10000).
```{r}
dining_count <- as.numeric(USD_food$Dining_Count)
diningCount_criterion<- !is.na(dining_count) & dining_count >= 0 & dining_count < 10000 

```

## h
The final number of observations after this cleaning is 134.
```{r}


final_food <- USD_food[age_criterion & state_criterion & expTotal_criterion & expGrocery_criterion & expDining_criterion & expmisc_criterion & diningCount_criterion, ]
length(final_food$ID)

```

# Problem 3
## a
```{r}
#' Function to computes the next number in its Collatz sequence
#'
#' @param x a positive integer
#' @return next number in its Collatz sequence for `x`
nextCollatz <- function(x) {
  # Check for invalid input
  if (!is.numeric(x) || length(x) != 1) {
    stop("Input must be a single numeric value.")
  }
  if (x <= 0 || x != as.integer(x)) {
    stop("Input must be a positive integer.")
  }
    
  if (x %% 2 == 0) {      
    next_x <- x / 2
  } else {
    next_x <- 3 * x + 1
  }
  return(next_x)
}
nextCollatz(5)
nextCollatz(16)
```

## b

```{r}
#' Function to computes a Collatz sequence for a number
#'
#' @param x a positive integer
#' @return next number in its Collatz sequence for `x`
collatzSequence <- function(x) {
  # Check for invalid input
  if (!is.numeric(x) || length(x) != 1) {
    stop("Input must be a single numeric value.")
  }
  if (x <= 0 || x != as.integer(x)) {
    stop("Input must be a positive integer.")
  }
    
  sequence <- c(x)
  num <- x
  while (num != 1){
    num = nextCollatz(num)
    sequence <- c(sequence, num)
  }
  return(list(sequence,length(sequence)))
}
collatzSequence(5)
collatzSequence(19)
```

## c
The shortest and longest Collatz sequence start with value 8 and 144
```{r}
shortest <- 1/0
longest <- -1/0
for (i in seq(100,500)){
  seq_len <- collatzSequence(i)[[2]]
  if (seq_len < shortest){
    shortest <- seq_len
  }
  if (seq_len > longest){
    longest <- seq_len
  }
}
shortest
longest
```
